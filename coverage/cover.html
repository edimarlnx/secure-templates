
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>secure-templates: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/edimarlnx/secure-templates/main.go (80.4%)</option>
				
				<option value="file1">github.com/edimarlnx/secure-templates/pkg/config/config.go (80.0%)</option>
				
				<option value="file2">github.com/edimarlnx/secure-templates/pkg/connectors/connector.go (54.5%)</option>
				
				<option value="file3">github.com/edimarlnx/secure-templates/pkg/connectors/local-file.go (67.9%)</option>
				
				<option value="file4">github.com/edimarlnx/secure-templates/pkg/connectors/print-keys.go (57.1%)</option>
				
				<option value="file5">github.com/edimarlnx/secure-templates/pkg/connectors/vault.go (0.0%)</option>
				
				<option value="file6">github.com/edimarlnx/secure-templates/pkg/helpers/helpers.go (76.7%)</option>
				
				<option value="file7">github.com/edimarlnx/secure-templates/pkg/render/funcs.go (61.1%)</option>
				
				<option value="file8">github.com/edimarlnx/secure-templates/pkg/render/template.go (85.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "crypto/md5"
        "encoding/base64"
        "fmt"
        config2 "github.com/edimarlnx/secure-templates/pkg/config"
        "github.com/edimarlnx/secure-templates/pkg/connectors"
        "github.com/edimarlnx/secure-templates/pkg/envs"
        "github.com/edimarlnx/secure-templates/pkg/helpers"
        "github.com/edimarlnx/secure-templates/pkg/logging"
        "github.com/edimarlnx/secure-templates/pkg/render"
        "github.com/sirupsen/logrus"
        "github.com/sirupsen/logrus/hooks/writer"
        "github.com/urfave/cli/v2"
        "io"
        "os"
        "time"
)

var (
        appName    = "secure-templates"
        appUsage   = "A template render tool"
        appVersion = "dev"
)

func main() <span class="cov0" title="0">{
        initApp(os.Args, nil)
}</span>

func initApp(args []string, outfile io.Writer) <span class="cov10" title="11">{
        workdir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                workdir = os.TempDir()
        }</span>
        <span class="cov10" title="11">var cfg config2.SecureTemplateConfig
        app := cli.NewApp()
        logging.Log.SetOutput(app.Writer)
        app.Name = appName
        app.Description = "Secure Templates is a tool to render templates using go-templates and load data values from secrets engine."
        app.Usage = appUsage
        app.Version = appVersion
        app.EnableBashCompletion = true
        var config, output, secretFile, passphrase string
        var printKeys bool
        if outfile != nil </span><span class="cov10" title="11">{
                app.Writer = outfile
        }</span>
        <span class="cov10" title="11">configFlag := cli.StringFlag{
                Name:        "config",
                Aliases:     []string{"c", "cfg"},
                EnvVars:     []string{envs.SecTplConfigEnv},
                Value:       "",
                Destination: &amp;config,
        }
        outputFlag := cli.StringFlag{
                Name:        "output",
                Aliases:     []string{"o", "out"},
                EnvVars:     []string{envs.SecTplOutputEnv},
                Value:       "",
                Destination: &amp;output,
        }

        app.Commands = []*cli.Command{
                {
                        Name:  "init-config",
                        Usage: "Init a sample config",
                        Flags: []cli.Flag{
                                &amp;outputFlag,
                                &amp;cli.StringFlag{
                                        Name:        "secret-file",
                                        Value:       fmt.Sprintf("%s/local-file-secret.json", workdir),
                                        Destination: &amp;secretFile,
                                },
                                &amp;cli.StringFlag{
                                        Name:        "private-key-passphrase",
                                        EnvVars:     []string{envs.LocalSecretPrivateKeyPassphraseEnv},
                                        Value:       "",
                                        Destination: &amp;passphrase,
                                },
                        },
                        Action: func(cCtx *cli.Context) error </span><span class="cov1" title="1">{
                                if passphrase == "" </span><span class="cov0" title="0">{
                                        passphrase = fmt.Sprintf("%x", md5.Sum([]byte(time.Now().String())))
                                }</span>
                                <span class="cov1" title="1">var privateKey []byte
                                privateKey, err = helpers.GenRsaPrivateKey(passphrase)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov1" title="1">cfg := config2.SecureTemplateConfig{
                                        SecretEngine: config2.SecretEngineLocalFile,
                                        LocalFileConfig: config2.LocalFileConfig{
                                                Filename:   secretFile,
                                                EncPrivKey: base64.StdEncoding.EncodeToString(privateKey),
                                                Passphrase: passphrase,
                                        },
                                        VaultConfig: config2.VaultConfig{
                                                Address:      "http://localhost:8200",
                                                Token:        "token",
                                                SecretEngine: "kv",
                                                Namespace:    "dev",
                                        },
                                }
                                outJson := cCtx.App.Writer
                                if output != "" </span><span class="cov1" title="1">{
                                        file, err := os.Create(output)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov1" title="1">outJson = file</span>
                                }
                                <span class="cov1" title="1">err = cfg.Json(outJson)
                                return err</span>
                        },
                },
                {
                        Name:  "manage-secret",
                        Usage: "Manage secret",
                        Flags: []cli.Flag{
                                &amp;configFlag,
                        },
                        Subcommands: []*cli.Command{
                                {
                                        Name:      "put",
                                        Usage:     "Add or update key value",
                                        UsageText: "put SECRET KEY VALUE",
                                        ArgsUsage: "[secret and key and value]",
                                        Args:      true,
                                        Action: func(cCtx *cli.Context) error <span class="cov6" title="4">{
                                                if len(cCtx.Args().Slice()) &lt; 3 </span><span class="cov0" title="0">{
                                                        return cli.Exit("Required secret, key and value args", 1)
                                                }</span>
                                                <span class="cov6" title="4">cfg := helpers.ParseConfig(config)
                                                connector := connectors.NewConnector(cfg)
                                                secret := cCtx.Args().Get(0)
                                                key := cCtx.Args().Get(1)
                                                value := cCtx.Args().Get(2)
                                                err := connector.WriteKey(secret, key, value)
                                                if err == nil </span><span class="cov6" title="4">{
                                                        logging.Log.Infof("Key '%s' saved on secret '%s'\n", key, secret)
                                                }</span>
                                                <span class="cov6" title="4">return err</span>
                                        },
                                },
                                {
                                        Name:      "import",
                                        Usage:     "Add or update key value using env file",
                                        UsageText: "import filepath",
                                        ArgsUsage: "[import and filepath]",
                                        Args:      true,
                                        Action: func(cCtx *cli.Context) error <span class="cov1" title="1">{
                                                if len(cCtx.Args().Slice()) &lt; 2 </span><span class="cov0" title="0">{
                                                        return cli.Exit("Required filename and secret args", 1)
                                                }</span>
                                                <span class="cov1" title="1">envFile := cCtx.Args().Get(1)
                                                data, err := helpers.ParseEnvFileAsKeyValue(envFile)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return cli.Exit(err.Error(), 1)
                                                }</span>
                                                <span class="cov1" title="1">cfg := helpers.ParseConfig(config)
                                                connector := connectors.NewConnector(cfg)
                                                secret := cCtx.Args().Get(0)
                                                err = connector.WriteKeys(secret, data)
                                                if err == nil </span><span class="cov1" title="1">{
                                                        logging.Log.Infof("%d keys saved on secret '%s'\n", len(data), secret)
                                                }</span>
                                                <span class="cov1" title="1">return err</span>
                                        },
                                },
                        },
                },
        }
        <span class="cov10" title="11">app.Flags = []cli.Flag{
                &amp;configFlag,
                &amp;outputFlag,
                &amp;cli.BoolFlag{
                        Name:        "print-keys",
                        Aliases:     []string{"p"},
                        Value:       false,
                        Destination: &amp;printKeys,
                },
        }
        app.Action = func(c *cli.Context) error </span><span class="cov7" title="5">{
                var connector connectors.Connector
                var printKeysValues map[string]int
                if printKeys </span><span class="cov1" title="1">{
                        printKeysValues = map[string]int{}
                        connector = &amp;connectors.PrintKeysConnector{
                                Keys: printKeysValues,
                        }
                }</span> else<span class="cov6" title="4"> {
                        if _, err := os.Stat(config); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return cli.Exit(fmt.Sprintf("Config file not found: %s", config), 1)
                        }</span>
                        <span class="cov6" title="4">cfg = helpers.ParseConfig(config)
                        connector = connectors.NewConnector(cfg)</span>
                }
                <span class="cov7" title="5">filename := c.Args().First()
                file, err := os.Open(filename)
                if err != nil </span><span class="cov0" title="0">{
                        return cli.Exit(fmt.Sprintf("Error on open input file %s", filename), 1)
                }</span>
                <span class="cov7" title="5">outputFile := c.App.Writer
                if output != "" &amp;&amp; output != "-" </span><span class="cov0" title="0">{
                        outputFile, err = os.Create(output)
                        if err != nil </span><span class="cov0" title="0">{
                                return cli.Exit(fmt.Sprintf("Error on open output file %s", filename), 1)
                        }</span>
                }
                <span class="cov7" title="5">logging.Log.AddHook(&amp;writer.Hook{
                        Writer: c.App.ErrWriter,
                        LogLevels: []logrus.Level{
                                logrus.WarnLevel,
                        },
                })
                if printKeys </span><span class="cov1" title="1">{
                        nullOutput, err := os.Create(os.DevNull)
                        if err != nil </span><span class="cov0" title="0">{
                                return cli.Exit("Error on open output file /dev/null", 1)
                        }</span>
                        <span class="cov1" title="1">err = render.ParseFile(cfg.Options, file, connector, nullOutput)
                        if err != nil </span><span class="cov0" title="0">{
                                return cli.Exit(err.Error(), 1)
                        }</span>
                        <span class="cov1" title="1">_, err = outputFile.Write([]byte("Template keys:\n"))
                        if err != nil </span><span class="cov0" title="0">{
                                return cli.Exit(err.Error(), 1)
                        }</span>
                        <span class="cov1" title="1">for key := range printKeysValues </span><span class="cov6" title="4">{
                                _, err := outputFile.Write([]byte("  " + key + "\n"))
                                if err != nil </span><span class="cov0" title="0">{
                                        return cli.Exit(err.Error(), 1)
                                }</span>
                        }

                } else<span class="cov6" title="4"> {
                        err := render.ParseFile(cfg.Options, file, connector, outputFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return cli.Exit(err.Error(), 1)
                        }</span>
                }
                <span class="cov7" title="5">return nil</span>
        }
        <span class="cov10" title="11">appArgs := args
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                appArgs = append(args, "-h")
        }</span>
        <span class="cov10" title="11">if err := app.Run(appArgs); err != nil </span><span class="cov0" title="0">{
                logging.Log.Error(err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "encoding/json"
        "io"
)

type SecretEngine string

const (
        SecretEngineVault     SecretEngine = "vault"
        SecretEngineLocalFile SecretEngine = "local-file"
        SecretEnginePrintKeys SecretEngine = "print-keys"
        //SecretEngineOnePassword SecretEngine = "one-password"
)

type SecureTemplateConfigOptions struct {
        SecretShowNameAsValueIfEmpty       bool   `json:"secretShowNameAsValueIfEmpty"`
        SecretIgnoreNotFoundKey            bool   `json:"secretIgnoreNotFoundKey"`
        EnvShowNameAsValueIfEmpty          bool   `json:"envShowNameAsValueIfEmpty"`
        EnvAllowAccessToSecureTemplateEnvs bool   `json:"envAllowAccessToSecureTemplateEnvs"`
        EnvRestrictedNameRegex             string `json:"envRestrictedNameRegex"`
}

type SecureTemplateConfig struct {
        SecretEngine SecretEngine `json:"secret_engine"`
        VaultConfig  VaultConfig  `json:"vault_config,omitempty"`
        //OnePasswordConfig OnePasswordConfig `json:"one_password_config,omitempty"`
        LocalFileConfig LocalFileConfig             `json:"local_file_config,omitempty"`
        Options         SecureTemplateConfigOptions `json:"options"`
}

type VaultConfig struct {
        Address      string `json:"address"`
        Token        string `json:"token,omitempty"`
        SecretEngine string `json:"secret_engine,omitempty"`
        Namespace    string `json:"ns,omitempty"`
}

type OnePasswordConfig struct {
}

type LocalFileConfig struct {
        Filename   string `json:"filename"`
        EncPrivKey string `json:"enc_priv_key,omitempty"`
        Passphrase string `json:"passphrase,omitempty"`
}

func (cfg *SecureTemplateConfig) Json(out io.Writer) error <span class="cov8" title="1">{
        data, err := json.MarshalIndent(cfg, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = out.Write(data)
        return err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package connectors

import (
        "github.com/edimarlnx/secure-templates/pkg/config"
        "github.com/edimarlnx/secure-templates/pkg/logging"
)

type Connector interface {
        Init(secTplConfig config.SecureTemplateConfig) error
        Secret(secretName, keyName string) any
        WriteKey(secretName, keyName, keyValue string) error
        WriteKeys(secretName string, keyValue map[string]string) error
        Finalize()
}

func NewConnector(secTplConfig config.SecureTemplateConfig) Connector <span class="cov10" title="9">{
        var connector Connector
        switch secTplConfig.SecretEngine </span>{
        case config.SecretEngineVault:<span class="cov0" title="0">
                connector = &amp;VaultConnector{}</span>
        case config.SecretEngineLocalFile:<span class="cov10" title="9">
                connector = &amp;LocalFileConnector{}</span>
        case config.SecretEnginePrintKeys:<span class="cov0" title="0">
                connector = &amp;PrintKeysConnector{}</span>
        default:<span class="cov0" title="0">
                logging.Log.Fatalf("Connector not implemented: %s\n", secTplConfig.SecretEngine)
                return nil</span>
        }
        <span class="cov10" title="9">err := connector.Init(secTplConfig)
        if err != nil </span><span class="cov0" title="0">{
                logging.Log.Fatalf("Error on init connector: %s\n", err.Error())
        }</span>
        <span class="cov10" title="9">return connector</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package connectors

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
        "encoding/base64"
        "github.com/edimarlnx/secure-templates/pkg/config"
        "github.com/edimarlnx/secure-templates/pkg/envs"
        "github.com/edimarlnx/secure-templates/pkg/helpers"
        "github.com/edimarlnx/secure-templates/pkg/logging"
        "github.com/go-jose/go-jose/v3/json"
        "os"
)

type LocalFileConnector struct {
        Connector
        secretFile                   string
        secrets                      map[string]map[string]string
        encPrivKey                   *rsa.PrivateKey
        encPubKey                    *rsa.PublicKey
        secretIgnoreNotFoundKey      bool
        secretShowNameAsValueIfEmpty bool
}

func (v *LocalFileConnector) Init(secTplConfig config.SecureTemplateConfig) error <span class="cov7" title="9">{
        v.secretFile = secTplConfig.LocalFileConfig.Filename
        v.secrets = map[string]map[string]string{}
        encPrivKey := helpers.GetEnv(envs.LocalSecretPrivateKeyEnv, secTplConfig.LocalFileConfig.EncPrivKey)
        if encPrivKey != "" </span><span class="cov7" title="9">{
                passphrase := helpers.GetEnv(envs.LocalSecretPrivateKeyPassphraseEnv, secTplConfig.LocalFileConfig.Passphrase)
                privKey, err := helpers.ParseRsaPrivateKeyFromPemStr(encPrivKey, passphrase)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov7" title="9">v.encPrivKey = privKey
                v.encPubKey = &amp;privKey.PublicKey</span>
        }
        <span class="cov7" title="9">v.secretShowNameAsValueIfEmpty = secTplConfig.Options.SecretShowNameAsValueIfEmpty
        v.secretIgnoreNotFoundKey = secTplConfig.Options.SecretIgnoreNotFoundKey
        return v.loadFromFile()</span>
}

func (v *LocalFileConnector) Secret(secretName, keyName string) any <span class="cov9" title="17">{
        secret := v.secrets[secretName]
        if secret == nil </span><span class="cov0" title="0">{
                logging.Log.Fatalf("secret not exists '%s'\n", secretName)
                return keyName
        }</span>
        <span class="cov9" title="17">if keyName != "" </span><span class="cov8" title="16">{
                value, ok := secret[keyName]
                if !ok </span><span class="cov0" title="0">{
                        if !v.secretIgnoreNotFoundKey </span><span class="cov0" title="0">{
                                logging.Log.Warnf("unable to load value for key %s\n", keyName)
                        }</span>
                        <span class="cov0" title="0">logging.Log.Warnf("unable to load value for key %s\n", keyName)
                        if v.secretShowNameAsValueIfEmpty </span><span class="cov0" title="0">{
                                return keyName
                        }</span>
                        <span class="cov0" title="0">return value</span>
                }
                <span class="cov8" title="16">encData, err := v.decrypt(value)
                if err != nil </span><span class="cov0" title="0">{
                        logging.Log.Fatalf("unable to decrypt value for key %s\n", keyName)
                }</span>
                <span class="cov8" title="16">return encData</span>
        }
        <span class="cov1" title="1">data := map[string]interface{}{}
        for k, vl := range secret </span><span class="cov6" title="8">{
                encData, err := v.decrypt(vl)
                if err != nil </span><span class="cov0" title="0">{
                        logging.Log.Fatalf("unable to decrypt value for key %s\n", keyName)
                }</span>
                <span class="cov6" title="8">data[k] = encData</span>
        }
        <span class="cov1" title="1">return data</span>
}

func (v *LocalFileConnector) Finalize() <span class="cov0" title="0">{
        if err := v.saveToFile(); err != nil </span><span class="cov0" title="0">{
                logging.Log.Fatal(err)
        }</span>
}

func (v *LocalFileConnector) WriteKey(secretName, keyName, keyValue string) error <span class="cov4" title="4">{
        return v.WriteKeys(secretName, map[string]string{keyName: keyValue})
}</span>

func (v *LocalFileConnector) WriteKeys(secretName string, keyValue map[string]string) error <span class="cov5" title="5">{
        secret := v.secrets[secretName]
        if secret == nil </span><span class="cov0" title="0">{
                v.secrets[secretName] = map[string]string{}
                secret = v.secrets[secretName]
        }</span>
        <span class="cov5" title="5">for key, value := range keyValue </span><span class="cov8" title="12">{
                encData, err := v.encrypt(value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="12">secret[key] = encData</span>
        }
        <span class="cov5" title="5">return v.saveToFile()</span>
}

func (v *LocalFileConnector) loadFromFile() error <span class="cov7" title="9">{
        data, err := os.ReadFile(v.secretFile)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                v.secrets = map[string]map[string]string{}
                return nil
        }</span>
        <span class="cov7" title="9">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="9">err = json.Unmarshal(data, &amp;v.secrets)
        return err</span>
}

func (v *LocalFileConnector) saveToFile() error <span class="cov5" title="5">{
        data, err := json.MarshalIndent(v.secrets, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="5">err = os.WriteFile(v.secretFile, data, 0700)
        return err</span>
}

func (v *LocalFileConnector) encrypt(str string) (string, error) <span class="cov8" title="12">{
        if v.encPubKey == nil </span><span class="cov0" title="0">{
                return str, nil
        }</span>
        <span class="cov8" title="12">encData, err := rsa.EncryptOAEP(
                sha256.New(),
                rand.Reader,
                v.encPubKey,
                []byte(str),
                nil)
        if err != nil </span><span class="cov0" title="0">{
                return str, err
        }</span>
        <span class="cov8" title="12">return base64.StdEncoding.EncodeToString(encData), nil</span>
}

func (v *LocalFileConnector) decrypt(str string) (string, error) <span class="cov10" title="24">{
        if v.encPrivKey == nil </span><span class="cov0" title="0">{
                return str, nil
        }</span>
        <span class="cov10" title="24">data, err := base64.StdEncoding.DecodeString(str)
        if err != nil </span><span class="cov0" title="0">{
                return str, err
        }</span>
        <span class="cov10" title="24">decData, err := rsa.DecryptOAEP(
                sha256.New(),
                rand.Reader,
                v.encPrivKey,
                data,
                nil)
        if err != nil </span><span class="cov0" title="0">{
                return str, err
        }</span>
        <span class="cov10" title="24">return string(decData), nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package connectors

import (
        "errors"
        "fmt"
        "github.com/edimarlnx/secure-templates/pkg/config"
)

type PrintKeysConnector struct {
        Connector
        Keys map[string]int
}

func (v *PrintKeysConnector) Init(_ config.SecureTemplateConfig) error <span class="cov0" title="0">{
        return nil
}</span>

func (v *PrintKeysConnector) Secret(secretName, keyName string) any <span class="cov10" title="4">{
        key := fmt.Sprintf("%s.%s", secretName, keyName)
        if v.Keys[key] == 0 </span><span class="cov10" title="4">{
                v.Keys[key] = 1
        }</span>
        <span class="cov10" title="4">return key</span>
}

func (v *PrintKeysConnector) Finalize() {<span class="cov0" title="0">

}</span>

func (v *PrintKeysConnector) WriteKey(_, _, _ string) error <span class="cov0" title="0">{
        return errors.New("not implemented for Print Keys")
}</span>

func (v *PrintKeysConnector) WriteKeys(_ string, _ map[string]string) error <span class="cov0" title="0">{
        return errors.New("not implemented for Print Keys")
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package connectors

import (
        "context"
        "errors"
        "fmt"
        "github.com/edimarlnx/secure-templates/pkg/config"
        "github.com/edimarlnx/secure-templates/pkg/envs"
        "github.com/edimarlnx/secure-templates/pkg/helpers"
        "github.com/edimarlnx/secure-templates/pkg/logging"
        vApi "github.com/hashicorp/vault/api"
        "strings"
)

type VaultConnector struct {
        Connector
        client                       *vApi.Client
        engineName                   string
        ns                           string
        kvSecrets                    map[string]*vApi.KVSecret
        secretIgnoreNotFoundKey      bool
        secretShowNameAsValueIfEmpty bool
}

func (v *VaultConnector) Init(secTplConfig config.SecureTemplateConfig) error <span class="cov0" title="0">{
        cfg := vApi.DefaultConfig()
        cfg.Address = helpers.GetEnv(envs.VaultAddrEnv, secTplConfig.VaultConfig.Address)
        client, err := vApi.NewClient(cfg)
        if err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("unable to initialize Vault client: %v", err)
                return errors.New(msg)
        }</span>
        <span class="cov0" title="0">token := helpers.GetEnv(envs.VaultTokenEnv, secTplConfig.VaultConfig.Token)
        if strings.TrimSpace(token) == "" </span><span class="cov0" title="0">{
                msg := "vault token is required"
                return errors.New(msg)
        }</span>
        <span class="cov0" title="0">client.SetToken(token)
        v.client = client
        v.engineName = helpers.GetEnv(envs.VaultSecretEngineEnv, secTplConfig.VaultConfig.SecretEngine)
        if v.engineName == "" </span><span class="cov0" title="0">{
                v.engineName = "kv"
        }</span>
        <span class="cov0" title="0">v.ns = helpers.GetEnv(envs.VaultNsEnv, secTplConfig.VaultConfig.Namespace)
        v.kvSecrets = map[string]*vApi.KVSecret{}
        v.secretShowNameAsValueIfEmpty = secTplConfig.Options.SecretShowNameAsValueIfEmpty
        v.secretIgnoreNotFoundKey = secTplConfig.Options.SecretIgnoreNotFoundKey
        return nil</span>
}

func (v *VaultConnector) Secret(secretName, keyName string) any <span class="cov0" title="0">{
        kvSecret := v.kvSecrets[secretName]
        if kvSecret == nil </span><span class="cov0" title="0">{
                var mountPath string
                if v.ns != "" </span><span class="cov0" title="0">{
                        mountPath = fmt.Sprintf("%s/%s", v.ns, secretName)
                }</span> else<span class="cov0" title="0"> {
                        mountPath = secretName
                }</span>
                <span class="cov0" title="0">kvSec, err := v.client.KVv2(v.engineName).Get(context.Background(), mountPath)
                if err != nil </span><span class="cov0" title="0">{
                        logging.Log.Fatalf("unable to read secret: %v\n", err)
                        return keyName
                }</span>
                <span class="cov0" title="0">v.kvSecrets[secretName] = kvSec
                kvSecret = kvSec</span>
        }
        <span class="cov0" title="0">if keyName != "" </span><span class="cov0" title="0">{
                value, ok := kvSecret.Data[keyName].(string)
                if !ok </span><span class="cov0" title="0">{
                        if !v.secretIgnoreNotFoundKey </span><span class="cov0" title="0">{
                                logging.Log.Fatalf("unable to load value for key %s\n", keyName)
                        }</span>
                        <span class="cov0" title="0">logging.Log.Printf("unable to load value for key %s\n", keyName)
                        if v.secretShowNameAsValueIfEmpty </span><span class="cov0" title="0">{
                                return keyName
                        }</span>
                }
                <span class="cov0" title="0">return value</span>
        }
        <span class="cov0" title="0">data := map[string]interface{}{}
        for k, vl := range kvSecret.Data </span><span class="cov0" title="0">{
                data[k] = vl
        }</span>
        <span class="cov0" title="0">return data</span>
}

func (v *VaultConnector) WriteKey(secretName, keyName, keyValue string) error <span class="cov0" title="0">{
        return v.WriteKeys(secretName, map[string]string{keyName: keyValue})
}</span>

func (v *VaultConnector) WriteKeys(secretName string, keyValue map[string]string) error <span class="cov0" title="0">{
        var secretPath string
        if v.ns != "" </span><span class="cov0" title="0">{
                secretPath = fmt.Sprintf("%s/%s", v.ns, secretName)
        }</span> else<span class="cov0" title="0"> {
                secretPath = secretName
        }</span>
        <span class="cov0" title="0">data := map[string]interface{}{}
        for key, value := range keyValue </span><span class="cov0" title="0">{
                data[key] = value
        }</span>
        <span class="cov0" title="0">secret, err := v.client.Logical().ReadWithContext(context.Background(), fmt.Sprintf("%s/data/%s", v.engineName, secretPath))
        if err != nil </span><span class="cov0" title="0">{
                logging.Log.Fatalf("unable to get secret: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">if secret == nil </span><span class="cov0" title="0">{
                _, err = v.client.KVv2(v.engineName).Put(context.Background(), secretPath, data)
        }</span> else<span class="cov0" title="0"> {
                _, err = v.client.KVv2(v.engineName).Patch(context.Background(), secretPath, data)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.Log.Fatalf("unable to write secret: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (v *VaultConnector) Finalize() {<span class="cov0" title="0">

}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package helpers

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/base64"
        "encoding/json"
        "encoding/pem"
        "errors"
        "github.com/edimarlnx/secure-templates/pkg/config"
        "github.com/edimarlnx/secure-templates/pkg/logging"
        "github.com/joho/godotenv"
        "os"
        "strings"
)

func GetEnv(name, defaultValue string) string <span class="cov10" title="22">{
        value := os.Getenv(name)
        if strings.TrimSpace(value) != "" </span><span class="cov5" title="4">{
                return value
        }</span>
        <span class="cov9" title="18">return defaultValue</span>
}

func ParseConfig(filename string) config.SecureTemplateConfig <span class="cov7" title="9">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                logging.Log.Fatalf("Error on parse config file: %s\n", filename)
        }</span>
        <span class="cov7" title="9">var cfg config.SecureTemplateConfig
        err = json.Unmarshal(data, &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                logging.Log.Fatalf("Error on parse config file: %s\n", filename)
        }</span>
        <span class="cov7" title="9">return cfg</span>
}

func GenRsaPrivateKey(pwd string) ([]byte, error) <span class="cov1" title="1">{
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">block := &amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
        }
        if pwd != "" </span><span class="cov1" title="1">{
                blk, err := x509.EncryptPEMBlock(rand.Reader, block.Type, block.Bytes, []byte(pwd), x509.PEMCipherAES256)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">block = blk</span>
        }
        <span class="cov1" title="1">privKeyPem := pem.EncodeToMemory(block)
        return privKeyPem, nil</span>
}

func ParseRsaPrivateKeyFromPemStr(privKeyBase64, pwd string) (*rsa.PrivateKey, error) <span class="cov7" title="9">{
        data, err := base64.StdEncoding.DecodeString(privKeyBase64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="9">block, _ := pem.Decode(data)
        if block == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to parse PEM block containing the key")
        }</span>
        <span class="cov7" title="9">var certData []byte
        if pwd != "" &amp;&amp; x509.IsEncryptedPEMBlock(block) </span><span class="cov7" title="9">{
                certData, err = x509.DecryptPEMBlock(block, []byte(pwd))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                certData = block.Bytes
        }</span>
        <span class="cov7" title="9">privKey, err := x509.ParsePKCS1PrivateKey(certData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="9">return privKey, nil</span>
}

func ParseEnvFileAsKeyValue(envFile string) (map[string]string, error) <span class="cov1" title="1">{
        data, err := godotenv.Read(envFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return data, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package render

import (
        "github.com/edimarlnx/secure-templates/pkg/config"
        "github.com/edimarlnx/secure-templates/pkg/connectors"
        "github.com/edimarlnx/secure-templates/pkg/envs"
        "github.com/edimarlnx/secure-templates/pkg/helpers"
        "github.com/edimarlnx/secure-templates/pkg/logging"
        "regexp"
        "slices"
)

var restrictedEnvVars []string
var allowEnvVarsRegex *regexp.Regexp

func RegisterSecret(connector connectors.Connector) func(args ...string) any <span class="cov5" title="5">{
        return func(args ...string) any </span><span class="cov10" title="21">{
                if len(args) == 1 </span><span class="cov1" title="1">{
                        return connector.Secret(args[0], "")
                }</span>
                <span class="cov9" title="20">return connector.Secret(args[0], args[1])</span>
        }
}

func RegisterEnvVar(cfgOptions config.SecureTemplateConfigOptions) func(string) string <span class="cov5" title="5">{
        if !cfgOptions.EnvAllowAccessToSecureTemplateEnvs </span><span class="cov5" title="5">{
                restrictedEnvVars = []string{
                        envs.LocalSecretPrivateKeyPassphraseEnv,
                        envs.SecTplConfigEnv,
                        envs.SecTplOutputEnv,
                        envs.LocalSecretPrivateKeyEnv,
                        envs.VaultAddrEnv,
                        envs.VaultTokenEnv,
                        envs.VaultSecretEngineEnv,
                        envs.VaultNsEnv,
                }
        }</span>
        <span class="cov5" title="5">if cfgOptions.EnvRestrictedNameRegex != "" </span><span class="cov0" title="0">{
                regex, err := regexp.Compile(cfgOptions.EnvRestrictedNameRegex)
                if err != nil </span><span class="cov0" title="0">{
                        logging.Log.Warnf("Error on parse regex: %s\n", cfgOptions.EnvRestrictedNameRegex)
                }</span> else<span class="cov0" title="0"> {
                        allowEnvVarsRegex = regex
                }</span>
        }

        <span class="cov5" title="5">return func(envName string) string </span><span class="cov5" title="4">{
                if slices.Contains(restrictedEnvVars, envName) || (allowEnvVarsRegex != nil &amp;&amp; !allowEnvVarsRegex.MatchString(envName)) </span><span class="cov0" title="0">{
                        logging.Log.Warnf("'%s' is a restricted variable name.\n", envName)
                        return ""
                }</span>
                <span class="cov5" title="4">if cfgOptions.EnvShowNameAsValueIfEmpty </span><span class="cov0" title="0">{
                        return helpers.GetEnv(envName, envName)
                }</span>
                <span class="cov5" title="4">return helpers.GetEnv(envName, "")</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package render

import (
        "github.com/Masterminds/sprig/v3"
        "github.com/edimarlnx/secure-templates/pkg/config"
        "github.com/edimarlnx/secure-templates/pkg/connectors"
        "io"
        "os"
        "path/filepath"
        "text/template"
)

func funcMap(cfgOptions config.SecureTemplateConfigOptions, connector connectors.Connector) template.FuncMap <span class="cov3" title="5">{
        funcMaps := template.FuncMap{}
        for k, v := range sprig.FuncMap() </span><span class="cov10" title="1050">{
                funcMaps[k] = v
        }</span>
        <span class="cov3" title="5">funcMaps["env"] = RegisterEnvVar(cfgOptions)
        funcMaps["secret"] = RegisterSecret(connector)
        return funcMaps</span>
}

func ParseFile(cfgOptions config.SecureTemplateConfigOptions, file *os.File, connector connectors.Connector, output io.Writer) error <span class="cov3" title="5">{
        tpl, err := template.New(filepath.Base(file.Name())).
                Funcs(funcMap(cfgOptions, connector)).
                ParseFiles(file.Name())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="5">return processTemplate(tpl, output)</span>
}

func processTemplate(tpl *template.Template, output io.Writer) error <span class="cov3" title="5">{
        err := tpl.Execute(output, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="5">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
